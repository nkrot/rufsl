Задание
=======

Натренировать и применить две модели пробелизатора. Потом изучить скрипты, которые используются для каждой стадии задачи.

A. Подготовка тренировочного корпуса
=====================================

Из /shared/monster1/data/contests/01-spaces.ru/

1) взять train.txt. вертикализировать его, вставить эталоные теги. Строки с #!# в тренировочном корпусе не нужны.

	> verticalize --add-tags

2) выбрать случайное подмножество этого корпуса (всего объема тренировочного корпуса будет слишком много - synb_crf не сможет обработать больше 5-6 тысяч блоков). Используйте следующий скрипт, в котором нужные параметры заданы хардкодом (по желанию можете их изменить).

	> get_random_subset

пусть файл с подготовленным тренировочным корпусом называется
	train_corpus.txt

Примерный вид тренировочного корпуса:

П	SI
р	SM
е	SM
м	SM
ь	SM
е	SM
р	SM
-	SM
м	SM
и	SM
н	SM
и	SM
с	SM
т	SM
р	SL
Ч	SI
е	SM
х	SM
и	SM
и	SL

3) проверьте правильность корпуса: убедитесь, что количество полей в строках совпадает.

	> count_fields

   Возможно, в корпус попали #-символы из оригинального корпуса. Эти символы могут неправильно обрабатываться скриптами (assign_properties), давая неправильное количество полей в выдаче.

B. Построение модели (тренировка)
=================================

Натренируйте простейшую подель, использующую несколько фич, построенных на основе только одного property - оригинальный текст символа (как показано выше).

1) заполните конфигурационный файл (допустим, файл называется crf_text_spacer.cfg). Необходимо заполнить следующие поля:

	TAGSET
	STR_WORD_FIELDS_COUNT
	INT_WORD_FIELDS_COUNT

2) напишите несколько униграммных фич (UG):

	a) фича для одного текущего символа
	b) фича для предыдущего символа + текущего символа
	c) другие комбинации символов

3) добавьте биграммную фичу (BG)

4) натренируйте модель (выходной файл: textspacer.bin)

	> cat train_corpus.txt | synb_crf --bin=textspacer.bin --min-feat=2 --config=crf_text_spacer.cfg

C. Применение модели
=====================

Тестировочный корпус необходимо подготовить способом, (почти) аналогичным тому, как был подготовлен тренировочный корпус. Отличие в том, что 1) необходимо сохранить лишние пустые строки между параграфами и 2) нет возможности указать эталонный тег

Из /shared/monster1/data/contests/01-spaces.ru/ необходимо взять train.txt и

1) вертикализировать его

	> verticalize --label-empty-lines

допустим, результирующий файл называется test_corpus.txt

2) убедитесь, что количество полей в строках совпадает.

3) протеггируйте текст при помощи ранее построенной модели

	> cat test_corpus.txt | synll_crf --bin=textspacer.bin --skip-line='#!#EMPTYLINE'

4) приведите вертикальный файл к горизонтальному, восстановив пробелы по вычисленным тегам 

	> restore_spaces

   полученный файл нужно скопировать в /shared/monster1/data/contests/01-spaces.ru/results
   и проверить результаты в таблице по адресу: http://postanogov/cgi-bin/contest01.pl



Часть 2
=======

Вторая модель должна учитывать некоторые дополнительные свойства, например, текст символа в нижнем регистре и другую регистровую информацию.

D. добавление новых properties
==============================

1) Разработайте скрипт assign_properties для добавления в виде property следующей информации

	a) текст буквы в нижнем регистре

	b) регистровую информацию о символе (lc_upper, lc_lower, lc_other, etc)

	> cat corpus_train.txt | assign_properties

примерный выход:

К	к	lc_upper	SI
а	а	lc_lower	SM
к	к	lc_lower	SL
у	у	lc_lower	SI
с	с	lc_lower	SM
п	п	lc_lower	SM
о	о	lc_lower	SM
к	к	lc_lower	SM
о	о	lc_lower	SM
и	и	lc_lower	SM
т	т	lc_lower	SM
ь	ь	lc_lower	SL
м	м	lc_lower	SI
л	л	lc_lower	SM
а	а	lc_lower	SM
д	д	lc_lower	SM
е	е	lc_lower	SM
н	н	lc_lower	SM
ц	ц	lc_lower	SM
а	а	lc_lower	SM


Используйте библиотеку ru_utf8.rb для работы со стороками в utf-8 (поддерживаются только русские буквы)

	require 'ru_utf8'
	"БаР Малей".downcase #=> "бар малей"

Скрипт assign_properies_krot дан для справки, там вы можете найти подсказки :)

E. Тренировка модели
====================

1) настройте конфигурационный файл

	STR_WORD_FIELDS_COUNT

2) добавте UG-фичи, использующие нововведенные properties

	a) фича/и для последовательностей символов в нижнем регистре

	b) фича/и для регистровой информации (lc_*), например, комбинированная фича, использующая геристровую информацию предыдущего и текущего символов, записывается так:
	UG	LC_PC	-1,2	0,2

3) постройте модель

	> cat train_corpus.txt | assign_properties | synb_crf --bin=textspacer.bin --min-feat=2 --config=crf_text_spacer.cfg

   или так

	> cat train_corpus.txt | assign_properties | tee train_corpus.feat | synb_crf --bin=textspacer.bin --min-feat=2 --config=crf_text_spacer.cfg

  если что-то не строится, проверьте правильность входных данных, как минимум количество полей в строках.

F. Применение модели
====================

Аналогично описанию в разделе C, меняется только п.3, так как надо вставить навешивание дополнительных свойств (так как тренировочный и тестировочный корпуса должны предоставлять одинаковую информацию, чтобы CRF работал!):

	> cat test_corpus.txt | assign_properties | synll_crf --bin=textspacer.bin --skip-line='#!#EMPTYLINE'

   или

	> cat test_corpus.txt | assign_properties | tee test_corpus.feat | synll_crf --bin=textspacer.bin --skip-line='#!#EMPTYLINE'


G. Freestyle
============

Теперь у вас есть все, чтобы поэкспериментировать с другими фичами.

Чтобы иметь возможность вернуться к любой версии, после каждой итерации сохраняйте (в отдельной директории) следующие файлы:

	assign_properties
	crf_text_spacer.cfg
	textspacer.bin



