Пошаговая инструкция, выполнять задание необходимо с Шага #1, ознакомившись с полной формулировкой

Задание (полная фомулировка) 
============================

(ниже см. пошаговую инструкцию, которой следует придерживаться)

Разработать скрипт, который находит в текстовых файлах указанные слова (или фразы) и выводит их в формате

	слово \tab позиция_в_предложении \tab предложение

Если указана опция -i или --ignore-case, то поиск осуществляется без учета регистра и вывод имеет вид:

	СЛОВО \tab позиция_в_предложении \tab предложение

По опции -t или --output-totals скрипт выводит на stderr статистику, сколько раз было найдено каждое из данных слов/фраз, в порядке уменьшения частоты.

	develop      \tab  120 
	Although     \tab  96 
	December     \tab  56 
	Bill Gates   \tab  22 
	Extensible Markup Language  \tab  1 
	U.S. Public Interest Research Group  \tab  1 

Файл со словами/фразами для поиска передается как первый аргумент в командной строке. Все остальные аргументы считаются текствыми файлами, в которых происходит поиск.

	> find_words queries.txt ../../data/corpus.tok.txt

Шаг #1
=======

Разработать код, выполняющий загрузку фраз для поиска из первого указанного аргумента.

	> find_words queries.txt ../../data/corpus.tok.txt

Игнорировать пустые строки, которые могут быть в файле queries.txt.

В какую структуру лучше загрузить данные?
>>> надо ответить на вопрос, как мы будем пользоваться этой структурой.

	if queries.include?(sentence_word)
		# current sentence contains the query
	end

начальный скрипт find_words_stub

ответ: find_words_1

Шаг #2
======

Реализуйте логику поиска одиночных слов из query.txt (игнорируйте 2x и более словные фразы) в предложениях из corpus.tok.txt. Результаты должны выводиться в формате:

	слово \tab позиция_в_предложении \tab предложение

ожидаемый выход в см. find_words_2.out
ответ: find_words_2

Шаг #3
======

Добавьте возможность осуществлять поиск как с учетом так и без учета регистра. Поведение по умолчанию - поиск с учетом регистра. По опции -i или --ignore-case поиск должен осуществляться без учета регистра. Во втором случае вывод должен быть в формате:

	СЛОВО \tab позиция_в_предложении \tab предложение

ожидаемый выход
	в режиме --ignore-case		find_words_3.out
	в режиме по умолчанию		find_words_2.out
ответ: find_words_3

Шаг #4
======

Добавьте короткую и длинную опции -t и --output-totals, по которой скрипт должен выводить на stderr статистику, сколько раз каждое из заданных слов было найдено в тексте. Без сортировки!
 
	develop	120 
	Although	96 
	December	56 
	Bill Gates	0
	Extensible Markup Language	0 
	U.S. Public Interest Research Group	0 

find_words --help должен содержать описание этой опции

ожидаемый выход (на stderr)
	в режиме -t		find_words_4.err
	в режиме -ti		find_words_4.ignorecase.err

ответ: find_words_4

!!! сделайте резерную копию вашего скрипта, она будет нужна для дополнительного задания (см. ниже) !!! 

Шаг #5
======

Сделайте так, чтобы скрипт искал не только отдельные слова, но и фразы (напр. Extensible Markup Language).

Возможное решение: раз хэш queries уже содержит многословные ключи:
{ ... "Extensible Markup Language" => 0,
      "Bill Gates" => 0,
      "U.S. Public Interest Research Group" => 0 }

то можно конструировать фразы из слов предложения и проверять их в queries. Например, если дано предложение:

	Netscape 6 supports Extensible Markup Language , Cascading Style Sheets 1 , and HTML 4.0 .

то из него можно сконструировать следующие фразы длины 3, среди которых есть искомая:

	Netscape 6 supports
	6 supports Extensible
	supports Extensible Markup
	Extensible Markup Language
	Markup Language ,
	Language , Cascading
	, Cascading Style
	Style Sheets 1
	Sheets 1 ,
	1 , and
	, and HTML
	and HTML 4.0
	HTML 4.0 .

Желательно конструировать фразы только тех длин, которые нужны. Если в queries.txt есть фразы только длин 2, 3 и 5, то только такие фразы и надо конструировать из предложений входного текста.

Кроме того, принимая, что отдельные слова это фразы длины 1, желательно разработать один общий алгоритм для обработки одно- и многословных фраз. Возможно, придется полностью выбрость логику поиска одиночных слов.

ожидаемый выход в режиме -t
	на stdout 	find_words_5.out
	на stderr	find_words_5.err

ожидаемый выход в режиме -ti
	на stdout 	find_words_5.ignorecase.out
	на stderr	find_words_5.ignorecase.err

ответ: find_words_5

Шаг #6
======

Сделайте так, чтобы статистика по количеству найденных слов/фраз выводилась в порядке от наиболее частотых к наименее частотным.

	develop	120 
	Although	96 
	December	56 
	Bill Gates	22 
	Extensible Markup Language	1 
	U.S. Public Interest Research Group	1

ожидаемый выход (на stderr)
	в режиме -t		find_words.err
	в режиме -ti		find_words.ignorecase.err

ответ: find_words

Дополнительное задание (необязательное)
=======================

Используя в качестве начального скрипта скрипт find_words_4 или ваш собственный вариант оного, измените скрипт так, чтобы он работал как можно медленнее. Используйте другие структуры данных, другие операции и тд. 

Сравните время выполнения двух версий скрипта, например, на трех последовательных запусках:

	> time -p for i in `seq 1 3`; do find_words_4 -ti queries.txt ../../data/corpus.tok.txt >/dev/null 2>/dev/null; done

real 2.63
user 1.90
sys 0.03


