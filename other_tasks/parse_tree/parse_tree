#!/usr/bin/env ruby

# TODO:
# 1. add rdoc documentation here
# 2. a method for checking is a tree is complete: well_formed? or single_top?
#    remember to ignore the fakeroot
# 3. see lesson.34/recursion/display_parse_tree#parse_bracketed_ps for an implementation
#    w/o Enumeration
#
# for rdoc:
# a fake root is added to ensure that even incomplete trees are handled

class ParseTree
  attr_accessor :name, :children, :verbose

  def initialize name=nil
    @name = name   if name
    @fakeroot = false
    @verbose = false
    @children = []
  end

  def set bracketed
    tokens = bracketed.split.to_enum
    @name = :top
    @fakeroot = true
    set_from_bracketed(tokens)
  end

  def to_s
    chunks = []
    children.each { |ch| chunks << ch.to_s }
    unless fakeroot?
      chunks.unshift(@name, "((")
      chunks << "))"
    end
    chunks.join(' ')
  end

  # display in vertical form indenting each level with 3 spaces
  # ignore the fake added top node
  def to_s_tree level=0
    str = ''

    if fakeroot?
      level -= 1
    else
      str << indent(level) << @name.to_s
    end

    children.each do |child|
      if child.is_a? self.class
        str << "\n" << child.to_s_tree(level+1)
      else
        str << "\n" << indent(level+1) << child
      end
    end
    str.sub!(/^\n/, '')

    str
  end

  def fakeroot?
    @fakeroot
  end

  def words
    words = []
    children.each do |child|
      if child.is_a? self.class
        words += child.words
      else
        words << child
      end
    end
    words
  end

  alias leaves words

  def word_count
    count = 0
    children.each do |child|
      count += child.is_a?(self.class) ? child.word_count : 1
    end
    count
  end

  protected

  def set_from_bracketed tokens
    verboser "set_from_bracketed called"

    loop do
      #begin
        token = tokens.next

        case token
        when '))'
          verboser "Seeing '#{token}' -- will return up"
          break

        when '(('
          verboser "Seeing '#{token}' -- will parse it as a subtree and add to children"

          tree = ParseTree.new
          tree.name = @children.pop # reconsider the decision wrt to previous token:
                                    # it was not a word but a node name
          tree.set_from_bracketed(tokens)

          @children << tree

        else
          verboser "Seeing '#{token}' -- this is either a word or node name, will add it to children"
          @children << token
        end

      #rescue StopIteration # wow! it is actually handled by Kernel#loop
      #  verboser "Scanning complete!"
      #  break
      #end
    end
  end

  def indent mult
    "   " * mult
  end

  def verboser msg
    if @verbose
      puts msg
    end
  end
end

if __FILE__ == $0
  parsings = [
    ["w__Sentence (( I_PP1A w__VB_XX (( love_VB w__N_XX (( w_NNS_HP_CC (( apples_NNS and_CC pears_NNS  ))  w__VBN_XX (( grown_VBN w__IN_N (( by_IN w__N_XX (( w_NNS (( my_PP$ grandparents_NNS  ))  w__IN_N (( in_IN w_NN (( their_PP$ garden_NN  ))   ))   ))   ))   ))   ))   ))   ))",
     12],

    ["w__Sentence (( I_PP1A w__VB_XX (( love_VB w_NNS_HP_CC (( apples_NNS and_CC pears_NNS  ))   ))   ))  that_CS w__Sentence (( w_NNS (( my_PP$ grandprents_NNS  ))  w__VB_XX (( grow_VB w__IN_N (( in_IN w_NN (( their_PP$ garden_NN  ))   ))   ))   ))",
     12]
  ]

  parsings.each do |(ps, et_word_count)|
    tree = ParseTree.new
    tree.set ps

#    p tree
    puts tree.to_s
    puts tree.to_s == ps.squeeze(' ')
    puts tree.to_s_tree
    puts tree.words.inspect
    puts tree.word_count == et_word_count
  end
end
