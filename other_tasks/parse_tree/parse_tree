#!/usr/bin/env ruby

# # #
# TODO:
# 1. add rdoc documentation here
# 2. a method for checking is a tree is complete: well_formed? or single_top?
#    remember to ignore the fakeroot
# 3. see lesson.34/recursion/display_parse_tree#parse_bracketed_ps for an implementation
#    w/o Enumeration
# 4. add a backlink to the parent
# 5. DFS/WFS scanning
# 6. [DONE] Store leaves as ParseTree objects. this is good for being able to
#    a) retrieve such nodes and be able to access their parent through a backlink
#
# for rdoc:
# a fake root is added to ensure that even incomplete trees are handled

class ParseTree
  attr_accessor :name, :children, :verbose
  attr_reader :leaf

  def initialize name=nil, is_leaf=false
    @name = name   if name
    @fakeroot = false
    @verbose = false
    @children = []
    @leaf = is_leaf
  end

  def set bracketed
    tokens = bracketed.split.to_enum
    @name = :top
    @fakeroot = true
    set_from_bracketed(tokens)
  end

  def to_s
    if leaf?
      name
    else
      chunks = []
      children.each { |ch| chunks << ch.to_s }
      unless fakeroot?
        chunks.unshift(@name, "((")
        chunks << "))"
      end
      chunks.join(' ')
    end
  end

  # display in vertical form indenting each level with 3 spaces
  # ignore the fake added top node
  def to_s_tree level=0
    str = ''

    if fakeroot?
      level -= 1
    else
      str << indent(level) << @name.to_s
    end

    children.each do |ch|
      if ch.leaf?
        str << "\n" << indent(level+1) << ch.name
      else
        str << "\n" << ch.to_s_tree(level+1)
      end
    end
    str.sub!(/^\n/, '')

    str
  end

  def leaf?
    @leaf
  end

  def fakeroot?
    @fakeroot
  end

  def leaves
    leaves = []
    children.each do |ch|
      if ch.leaf?
        leaves << ch
      else
        leaves += ch.leaves
      end
    end
    leaves
  end

  def words
    leaves.map { |node| node.name }
  end

  def word_count
    leaves.length
  end

  protected

  def set_from_bracketed tokens
    verboser "set_from_bracketed called"

    loop do
      #begin
      token = tokens.next

      case token
      when '))'
        verboser "Seeing '#{token}' -- will return up"
        break

      when '(('
        verboser "Seeing '#{token}' -- will parse it as a subtree and add to children"

        # reconsider the decision wrt to previous token:
        # it was not a word but a new node (subtree) name
        tree = @children.last
        tree.leaf = false
        tree.set_from_bracketed(tokens)

      else
        verboser "Seeing '#{token}' -- this is either a word or node name, will add it to children"
        tree = ParseTree.new(token, leaf=true)
        @children << tree

      end

      #rescue StopIteration # wow! it is actually handled by Kernel#loop
      #  verboser "Scanning complete!"
      #  break
      #end
    end
  end

  def indent mult
    "   " * mult
  end

  def leaf= val
    @leaf = val
  end

  def verboser msg
    if @verbose
      puts msg
    end
  end
end

######################################################################

if __FILE__ == $0
  parsings = [
    ["w__Sentence (( I_PP1A w__VB_XX (( love_VB w__N_XX (( w_NNS_HP_CC (( apples_NNS and_CC pears_NNS  ))  w__VBN_XX (( grown_VBN w__IN_N (( by_IN w__N_XX (( w_NNS (( my_PP$ grandparents_NNS  ))  w__IN_N (( in_IN w_NN (( their_PP$ garden_NN  ))   ))   ))   ))   ))   ))   ))   ))",
     12],

    ["w__Sentence (( I_PP1A w__VB_XX (( love_VB w_NNS_HP_CC (( apples_NNS and_CC pears_NNS  ))   ))   ))  that_CS w__Sentence (( w_NNS (( my_PP$ grandprents_NNS  ))  w__VB_XX (( grow_VB w__IN_N (( in_IN w_NN (( their_PP$ garden_NN  ))   ))   ))   ))",
     12]
  ]

  parsings.each do |(ps, et_word_count)|
    tree = ParseTree.new
    tree.set ps

#    p tree
    puts tree.to_s
    puts tree.to_s == ps.squeeze(' ')
    puts tree.to_s_tree

#    puts tree.leaves.inspect
    puts tree.words.inspect
    puts tree.word_count == et_word_count
  end
end
